        -:    0:Source:../src/driver/can/src/can_driver.c
        -:    0:Graph:src/driver/can/src/can_driver.gcno
        -:    0:Data:src/driver/can/src/can_driver.gcda
        -:    0:Runs:3
        -:    1:#ifdef __cplusplus
        -:    2:extern "C" {
        -:    3:#endif
        -:    4:/*******************************************************************************
        -:    5: * Include
        -:    6: ******************************************************************************/
        -:    7:#include "can_driver.h"
        -:    8:#include <stdio.h>
        -:    9:
        -:   10:/*******************************************************************************
        -:   11: * Macros
        -:   12: ******************************************************************************/
        -:   13:#define NUM_BYTES_EACH_WORD (4U)
        -:   14:#define MAX_NUMBER_OF_WORD (18U)
        -:   15:
        -:   16:#define ONE_BYTE (8U)
        -:   17:#define THREE_BYTES (24U)
        -:   18:#define FLEXCAN_0_INDEX (0u)
        -:   19:#define FLEXCAN_1_INDEX (1u)
        -:   20:#define FLEXCAN_2_INDEX (2u)
        -:   21:
        -:   22:#define FLEXCAN_INSTANCE_0 (0u)
        -:   23:#define FLEXCAN_INSTANCE_1 (1u)
        -:   24:#define FLEXCAN_INSTANCE_2 (2u)
        -:   25:
        -:   26:#define CAN_INSTANCE_NUMBER (3U)
        -:   27:
        -:   28:#define WORD_LENGTH (4u)
        -:   29:#define RANGE_OF_MB (uint8_t)(512 / (WORD_LENGTH * NUM_BYTES_EACH_WORD))
        -:   30:
        -:   31:/*******************************************************************************
        -:   32: * Variable Definiion
        -:   33: ******************************************************************************/
        -:   34:
        -:   35:// static uint8_t s_mbWordLength;
        -:   36:// static uint8_t RANGE_OF_MB;
        -:   37:static FlexCAN_CallbackIRQ s_callbackIrq_0;
        -:   38:static FlexCAN_CallbackIRQ s_callbackIrq_1;
        -:   39:static FlexCAN_CallbackIRQ s_callbackIrq_2;
        -:   40:// CAN_Type *const insCanBase[CAN_INSTANCE_NUMBER] = CAN_BASE_PTRS; /* (0x40024000u, 0x40025000u, 0x4002B000u } */
        -:   41:
        -:   42:/*******************************************************************************
        -:   43: * Prototypes
        -:   44: ******************************************************************************/
        -:   45:/**
        -:   46: * @brief     Enter freeze mode
        -:   47: *
        -:   48: * @param[in] instance: Input instance
        -:   49: *
        -:   50: * @return    None
        -:   51: */
        -:   52:static void FlexCAN_Enter_Freeze_Mode(uint32_t instance);
        -:   53:/**
        -:   54: * @brief     Exit freeze mode
        -:   55: *
        -:   56: * @param[in] instance: Input instance
        -:   57: *
        -:   58: * @return    None
        -:   59: */
        -:   60:static void FlexCAN_Exit_Freeze_Mode(uint32_t instance);
        -:   61:/**
        -:   62: * @brief     Clear all message buffers
        -:   63: *
        -:   64: * @param[in] instance: Input instance
        -:   65: *
        -:   66: * @return    None
        -:   67: */
        -:   68:static void FlexCAN_Clear_Message_Buffer(uint32_t instance);
        -:   69:/**
        -:   70: * @brief     Set bit rate
        -:   71: *
        -:   72: * @param[in] instance: Input instance
        -:   73: * @param[in] bit_timing: Input data to config bit rate
        -:   74: *
        -:   75: * @return    None
        -:   76: */
        -:   77:static void FlexCAN_Set_Bit_Rate(uint32_t instance, FlexCAN_bit_timing_t *bit_timing);
        -:   78:/**
        -:   79: * @brief     Get base address according to instance
        -:   80: *
        -:   81: * @param[in]  instance: Input instance
        -:   82: * @param[out] bassAddress: Output CAN base address with respective instance
        -:   83: *
        -:   84: * @return    FLEXCAN_RETURN_CODE_SUCCESS    : Valid input instance
        -:   85: *            FLEXCAN_RETURN_CODE_INVALID_INS: Invalid input instance
        -:   86: */
        -:   87:static FlexCAN_ReturnCode_t FlexCAN_Get_Base_Address(uint32_t instance, CAN_Type **bassAddress);
        -:   88:
        -:   89:/*******************************************************************************
        -:   90: * Function
        -:   91: ******************************************************************************/
function FlexCAN_Get_Base_Address called 261 returned 100% blocks executed 100%
      261:   92:static FlexCAN_ReturnCode_t FlexCAN_Get_Base_Address(uint32_t instance, CAN_Type **bassAddress)
        -:   93:{
      261:   94:    FlexCAN_ReturnCode_t retVal = FLEXCAN_RETURN_CODE_SUCCESS;
        -:   95:
      261:   96:    if (instance == FLEXCAN_INSTANCE_0)
branch  0 taken 195 (fallthrough)
branch  1 taken 66
        -:   97:    {
      195:   98:        *bassAddress = CAN0;
        -:   99:    }
       66:  100:    else if (instance == FLEXCAN_INSTANCE_1)
branch  0 taken 21 (fallthrough)
branch  1 taken 45
        -:  101:    {
       21:  102:        *bassAddress = CAN1;
        -:  103:    }
       45:  104:    else if (instance == FLEXCAN_INSTANCE_2)
branch  0 taken 21 (fallthrough)
branch  1 taken 24
        -:  105:    {
       21:  106:        *bassAddress = CAN2;
        -:  107:    }
        -:  108:    else
        -:  109:    {
       24:  110:        retVal = FLEXCAN_RETURN_CODE_INVALID_INS;
        -:  111:    }
        -:  112:
      261:  113:    return retVal;
        -:  114:}
        -:  115:
function FlexCAN_Enter_Freeze_Mode called 24 returned 100% blocks executed 100%
       24:  116:static void FlexCAN_Enter_Freeze_Mode(uint32_t instance)
        -:  117:{
       24:  118:    FlexCAN_ReturnCode_t retVal = FLEXCAN_RETURN_CODE_FAIL;
        -:  119:    CAN_Type *sp_base;
        -:  120:
       24:  121:    retVal = FlexCAN_Get_Base_Address(instance, &sp_base);
call    0 returned 24
        -:  122:    /* Enable to enter FreezeMode */
       24:  123:    sp_base->MCR = (sp_base->MCR & ~CAN_MCR_FRZ_MASK) | CAN_MCR_FRZ(1U);
        -:  124:    /* Enter FreezeMode */
       24:  125:    sp_base->MCR = (sp_base->MCR & ~CAN_MCR_HALT_MASK) | CAN_MCR_HALT(1U);
        -:  126:    /* Check whether bit MDIS in CAN_MCR is set to 1. If it is, clear it to 0 */
       24:  127:    if (((sp_base->MCR & CAN_MCR_MDIS_MASK) >> CAN_MCR_MDIS_SHIFT) != 0U)
branch  0 taken 12 (fallthrough)
branch  1 taken 12
        -:  128:    {
       12:  129:        sp_base->MCR &= ~CAN_MCR_MDIS_MASK;
        -:  130:    }
    23729:  131:    while ((sp_base->MCR & CAN_MCR_FRZACK_MASK) == 0U)
branch  0 taken 23705
branch  1 taken 24 (fallthrough)
        -:  132:    {
        -:  133:        /* do nothing to wait enter freezeMode */
        -:  134:    }
       24:  135:}
        -:  136:
function FlexCAN_Exit_Freeze_Mode called 24 returned 100% blocks executed 100%
       24:  137:static void FlexCAN_Exit_Freeze_Mode(uint32_t instance)
        -:  138:{
       24:  139:    FlexCAN_ReturnCode_t retVal = FLEXCAN_RETURN_CODE_FAIL;
        -:  140:    CAN_Type *sp_base;
        -:  141:
       24:  142:    retVal = FlexCAN_Get_Base_Address(instance, &sp_base);
call    0 returned 24
        -:  143:    /* No Freeze mode request */
       24:  144:    sp_base->MCR = (sp_base->MCR & ~CAN_MCR_HALT_MASK) | CAN_MCR_HALT(0U);
        -:  145:    /* Disable to enter FreezeMode */
       24:  146:    sp_base->MCR = (sp_base->MCR & ~CAN_MCR_FRZ_MASK) | CAN_MCR_FRZ(0U);
        -:  147:
     7063:  148:    while ((sp_base->MCR & CAN_MCR_FRZACK_MASK) != 0U)
branch  0 taken 7039
branch  1 taken 24 (fallthrough)
        -:  149:    {
        -:  150:        /* do nothing to sure exit freezeMode */
        -:  151:    }
        -:  152:    /* Check FlexCAN module is either in Normal mode, Listen-Only mode, or Loop-Back mode */
       24:  153:    while ((sp_base->MCR & CAN_MCR_NOTRDY_MASK) != 0U)
branch  0 taken 0
branch  1 taken 24 (fallthrough)
        -:  154:    {
        -:  155:        /* do nothing */
        -:  156:    }
       24:  157:}
        -:  158:
function FlexCAN_Clear_Message_Buffer called 12 returned 100% blocks executed 100%
       12:  159:static void FlexCAN_Clear_Message_Buffer(uint32_t instance)
        -:  160:{
       12:  161:    FlexCAN_ReturnCode_t retVal = FLEXCAN_RETURN_CODE_FAIL;
        -:  162:    CAN_Type *sp_base;
        -:  163:
       12:  164:    retVal = FlexCAN_Get_Base_Address(instance, &sp_base);
call    0 returned 12
       12:  165:    uint8_t index = 0;
        -:  166:
        -:  167:    /* CAN0: clear 32 message buffers x 4 words/msg buf = 128 words */
     1548:  168:    for (index = 0; index < CAN_RAMn_COUNT; index++)
branch  0 taken 1536
branch  1 taken 12 (fallthrough)
        -:  169:    {
        -:  170:        /* Clear msg buf word */
     1536:  171:        sp_base->RAMn[index] = 0U;
        -:  172:    }
       12:  173:}
        -:  174:
function FlexCAN_Set_Bit_Rate called 12 returned 100% blocks executed 100%
       12:  175:static void FlexCAN_Set_Bit_Rate(uint32_t instance, FlexCAN_bit_timing_t *bitTiming)
        -:  176:{
       12:  177:    FlexCAN_ReturnCode_t retVal = FLEXCAN_RETURN_CODE_FAIL;
        -:  178:    CAN_Type *sp_base;
        -:  179:
       12:  180:    retVal = FlexCAN_Get_Base_Address(instance, &sp_base);
call    0 returned 12
       12:  181:    sp_base->CTRL1 = CAN_CTRL1_PRESDIV(bitTiming->presdiv) |
       12:  182:                     CAN_CTRL1_RJW(bitTiming->rjw) |
       12:  183:                     CAN_CTRL1_PSEG1(bitTiming->pseg1) |
       12:  184:                     CAN_CTRL1_PSEG2(bitTiming->pseg2) |
       12:  185:                     CAN_CTRL1_SMP(bitTiming->smp) |
       12:  186:                     CAN_CTRL1_PROPSEG(bitTiming->propseg);
       12:  187:}
        -:  188:
function FlexCAN_Config_Tx_MessageBuffer called 48 returned 100% blocks executed 100%
       48:  189:FlexCAN_ReturnCode_t FlexCAN_Config_Tx_MessageBuffer(uint32_t instance, uint8_t indexOfMB, FlexCAN_TX_MessageBuffer_t *DataOfMB)
        -:  190:{
        -:  191:    CAN_Type *sp_base;
       48:  192:    uint8_t dataLength = 0;
       48:  193:    uint8_t indexOfData = 0;
       48:  194:    FlexCAN_ReturnCode_t retVal = FLEXCAN_RETURN_CODE_FAIL;
       48:  195:    uint8_t byteIndex = 0;
       48:  196:    uint8_t IndexOfRAM = 0;
        -:  197:    uint32_t *mbData;
        -:  198:
       48:  199:    mbData = (uint32_t *)DataOfMB;
       48:  200:    retVal = FlexCAN_Get_Base_Address(instance, &sp_base);
call    0 returned 48
        -:  201:    /* DLC max value is 8  with CAN 2.0 standard frame */
       48:  202:    if (FLEXCAN_RETURN_CODE_SUCCESS == retVal)
branch  0 taken 45 (fallthrough)
branch  1 taken 3
        -:  203:    {
       45:  204:        if (indexOfMB <= RANGE_OF_MB)
branch  0 taken 42 (fallthrough)
branch  1 taken 3
        -:  205:        {
       42:  206:            retVal = FLEXCAN_RETURN_CODE_SUCCESS;
        -:  207:        }
        -:  208:        else
        -:  209:        {
        3:  210:            retVal = FLEXCAN_RETURN_CODE_FAIL;
        -:  211:        }
        -:  212:    }
        -:  213:
       48:  214:    if (FLEXCAN_RETURN_CODE_SUCCESS == retVal)
branch  0 taken 42 (fallthrough)
branch  1 taken 6
        -:  215:    {
       42:  216:        dataLength = (uint8_t)(DataOfMB->cfControl.dlc);
        -:  217:        /* Write the payload date bytes */
      378:  218:        for (indexOfData = 0; indexOfData < dataLength; indexOfData++)
branch  0 taken 336
branch  1 taken 42 (fallthrough)
        -:  219:        {
      336:  220:            byteIndex = indexOfData / NUM_BYTES_EACH_WORD;
      336:  221:            IndexOfRAM = indexOfMB * WORD_LENGTH + OFFSET_START_OF_DATA_MB + byteIndex;
        -:  222:            /* write data for each byte of word by sequence */
      336:  223:            sp_base->RAMn[IndexOfRAM] = sp_base->RAMn[IndexOfRAM] << ONE_BYTE;
      336:  224:            sp_base->RAMn[IndexOfRAM] |= DataOfMB->dataByte[indexOfData];
        -:  225:        }
        -:  226:        /* Config the Control and Status word with desired configuration */
       42:  227:        sp_base->RAMn[indexOfMB * WORD_LENGTH + OFFSET_START_OF_MB] = 0U;
       42:  228:        sp_base->RAMn[indexOfMB * WORD_LENGTH + OFFSET_START_OF_MB] = *mbData;
       42:  229:        sp_base->RAMn[indexOfMB * WORD_LENGTH + OFFSET_ID_OF_MB] = 0U;
       42:  230:        sp_base->RAMn[indexOfMB * WORD_LENGTH + OFFSET_ID_OF_MB] = *(mbData + 1);
        -:  231:        /* Activate the message buffer to transmit the CAN frame */
       42:  232:        sp_base->RAMn[indexOfMB * WORD_LENGTH + OFFSET_START_OF_MB] &= ~(MB_CODE_MASK);
       42:  233:        sp_base->RAMn[indexOfMB * WORD_LENGTH + OFFSET_START_OF_MB] |= (CODE_SEND << MB_CODE_SHIFT);
        -:  234:    }
        -:  235:
       48:  236:    return retVal;
        -:  237:}
        -:  238:
        -:  239:/* CAN FD disable, IRMQ disable */
        -:  240:/*
        -:  241: * wordSize = 4: -> 8 bytes payload -> plus 2 word for configuration field
        -:  242: * wordSize = 6: -> 16 bytes payload
        -:  243: * wordSize = 10: -> 32 bytes payload
        -:  244: * wordSize = 18: -> 64 bytes payload
        -:  245: */
function FlexCAN_Init called 21 returned 100% blocks executed 100%
       21:  246:FlexCAN_ReturnCode_t FlexCAN_Init(uint32_t instance, uint8_t wordSize, FlexCAN_bit_timing_t *bitTiming)
        -:  247:{
       21:  248:    FlexCAN_ReturnCode_t retVal = FLEXCAN_RETURN_CODE_FAIL;
        -:  249:    CAN_Type *sp_base;
        -:  250:
       21:  251:    retVal = FlexCAN_Get_Base_Address(instance, &sp_base);
call    0 returned 21
       21:  252:    if (retVal == FLEXCAN_RETURN_CODE_SUCCESS)
branch  0 taken 18 (fallthrough)
branch  1 taken 3
        -:  253:    {
       18:  254:        if ((bitTiming != NULL) && (wordSize <= MAX_NUMBER_OF_WORD))
branch  0 taken 15 (fallthrough)
branch  1 taken 3
branch  2 taken 12 (fallthrough)
branch  3 taken 3
        -:  255:        {
        -:  256:            /* enable clock to CAN_Driver0 */
        -:  257:            // PCC->PCCn[PCC_FlexCAN0_INDEX] |= PCC_PCCn_CGC_MASK;
        -:  258:            /* Disable module before selecting clock   */
       12:  259:            sp_base->MCR |= CAN_MCR_MDIS_MASK;
        -:  260:            /* CLKSRC=0 -> CAN engine clock source is the oscillator clock, the oscillator clock frequency must be lower than bus clock */
       12:  261:            sp_base->CTRL1 &= ~CAN_CTRL1_CLKSRC_MASK;
        -:  262:            /* Enter freeze mode */
       12:  263:            FlexCAN_Enter_Freeze_Mode(instance);
call    0 returned 12
       12:  264:            FlexCAN_Set_Bit_Rate(instance, bitTiming);
call    0 returned 12
       12:  265:            FlexCAN_Clear_Message_Buffer(instance);
call    0 returned 12
        -:  266:            /* Self-reception disabled -> module cannot receive frames which are transmitted by itself */
       12:  267:            sp_base->MCR = (sp_base->MCR & ~CAN_MCR_SRXDIS_MASK) | CAN_MCR_SRXDIS(1U);
        -:  268:            /* Exit freeze mode */
       12:  269:            FlexCAN_Exit_Freeze_Mode(instance);
call    0 returned 12
        -:  270:            /* Check whether FlexCAN is synchronized to the CAN bus and able to join communication process */
       12:  271:            if ((sp_base->ESR1 >> CAN_ESR1_SYNCH_SHIFT) & CAN_ESR1_SYNCH_WIDTH)
branch  0 taken 3 (fallthrough)
branch  1 taken 9
        -:  272:            {
        3:  273:                retVal = FLEXCAN_RETURN_CODE_SUCCESS;
        -:  274:            }
        -:  275:        }
        -:  276:        else
        -:  277:        {
        6:  278:            retVal = FLEXCAN_RETURN_CODE_FAIL;
        -:  279:        }
        -:  280:    }
        -:  281:
       21:  282:    return retVal;
        -:  283:}
        -:  284:
function FlexCAN_Config_RX_MessageBuffer called 12 returned 100% blocks executed 100%
       12:  285:FlexCAN_ReturnCode_t FlexCAN_Config_RX_MessageBuffer(uint32_t instance, uint8_t IndexOfMb, FlexCAN_RX_MessageBuffer_t *config)
        -:  286:{
       12:  287:    uint8_t index = 0;
       12:  288:    FlexCAN_ReturnCode_t retVal = FLEXCAN_RETURN_CODE_FAIL;
        -:  289:    CAN_Type *sp_base;
        -:  290:
       12:  291:    retVal = FlexCAN_Get_Base_Address(instance, &sp_base);
call    0 returned 12
       12:  292:    if (retVal == FLEXCAN_RETURN_CODE_SUCCESS)
branch  0 taken 9 (fallthrough)
branch  1 taken 3
        -:  293:    {
        9:  294:        if ((config->cfID.id <= MB_ID_MASK) && (IndexOfMb <= RANGE_OF_MB))
branch  0 taken 6 (fallthrough)
branch  1 taken 3
        -:  295:        {
        6:  296:            if ((((sp_base->RAMn[IndexOfMb * WORD_LENGTH + OFFSET_START_OF_MB]) >> MB_CODE_SHIFT) & 0x0F) != CODE_INACTIVE_RX)
branch  0 taken 3 (fallthrough)
branch  1 taken 3
        -:  297:            {
        3:  298:                sp_base->RAMn[IndexOfMb * WORD_LENGTH + OFFSET_START_OF_MB] &= ~(MB_CODE_MASK);
        3:  299:                sp_base->RAMn[IndexOfMb * WORD_LENGTH + OFFSET_START_OF_MB] |= (CODE_INACTIVE_RX << MB_CODE_SHIFT);
        -:  300:            }
        6:  301:            FlexCAN_Enter_Freeze_Mode(instance);
call    0 returned 6
        -:  302:            /* Set Rx Global mask*/
        6:  303:            sp_base->RXMGMASK = 0;
        6:  304:            sp_base->RXMGMASK = config->RxIdMask;
        -:  305:            /* Set Rx Global mask */
        6:  306:            sp_base->RXIMR[IndexOfMb] = config->RxIdFilter;
        6:  307:            sp_base->RXIMR[IndexOfMb] = config->RxIdFilter;
        6:  308:            FlexCAN_Exit_Freeze_Mode(instance);
call    0 returned 6
        -:  309:            /* Set config for MB, write 0b0100 to Control and Status word to activate MB */
        6:  310:            sp_base->RAMn[IndexOfMb * WORD_LENGTH + OFFSET_START_OF_MB] &= ~(MB_CODE_MASK);
        6:  311:            sp_base->RAMn[IndexOfMb * WORD_LENGTH + OFFSET_START_OF_MB] = (CODE_RECEIVE_EMPTY << MB_CODE_SHIFT) | (config->cfControl.ide << MB_IDE_SHIFT);
        -:  312:            /* Write the ID word */
        6:  313:            sp_base->RAMn[IndexOfMb * WORD_LENGTH + OFFSET_ID_OF_MB] = 0;
        6:  314:            sp_base->RAMn[IndexOfMb * WORD_LENGTH + OFFSET_ID_OF_MB] = config->cfID.id;
        6:  315:            retVal = FLEXCAN_RETURN_CODE_SUCCESS;
        -:  316:        }
        -:  317:        else
        -:  318:        {
        3:  319:            retVal = FLEXCAN_RETURN_CODE_FAIL;
        -:  320:        }
        -:  321:    }
        -:  322:
       12:  323:    return retVal;
        -:  324:}
        -:  325:
function FlexCAN_ClearInterruptFlag called 36 returned 100% blocks executed 100%
       36:  326:FlexCAN_ReturnCode_t FlexCAN_ClearInterruptFlag(uint32_t instance, uint32_t flagIndex)
        -:  327:{
       36:  328:    FlexCAN_ReturnCode_t retVal = FLEXCAN_RETURN_CODE_FAIL;
        -:  329:    CAN_Type *sp_base;
        -:  330:
       36:  331:    retVal = FlexCAN_Get_Base_Address(instance, &sp_base);
call    0 returned 36
       36:  332:    if (retVal == FLEXCAN_RETURN_CODE_SUCCESS)
branch  0 taken 33 (fallthrough)
branch  1 taken 3
        -:  333:    {
       33:  334:        if (flagIndex <= RANGE_OF_MB)
branch  0 taken 30 (fallthrough)
branch  1 taken 3
        -:  335:        {
       30:  336:            sp_base->IFLAG1 |= (1 << flagIndex);
       30:  337:            retVal = FLEXCAN_RETURN_CODE_SUCCESS;
        -:  338:        }
        -:  339:        else
        -:  340:        {
        3:  341:            retVal = FLEXCAN_RETURN_CODE_FAIL;
        -:  342:        }
        -:  343:    }
        -:  344:
       36:  345:    return retVal;
        -:  346:}
        -:  347:
function FlexCAN_Send called 24 returned 100% blocks executed 100%
       24:  348:FlexCAN_ReturnCode_t FlexCAN_Send(uint32_t instance, uint8_t IndexOfMb, FlexCAN_TX_MessageBuffer_t *mbData)
        -:  349:{
       24:  350:    FlexCAN_ReturnCode_t retVal = FLEXCAN_RETURN_CODE_FAIL;
        -:  351:    CAN_Type *sp_base;
        -:  352:
       24:  353:    retVal = FlexCAN_Get_Base_Address(instance, &sp_base);
call    0 returned 24
       24:  354:    if (retVal == FLEXCAN_RETURN_CODE_SUCCESS)
branch  0 taken 21 (fallthrough)
branch  1 taken 3
        -:  355:    {
       21:  356:        if (mbData != NULL)
branch  0 taken 18 (fallthrough)
branch  1 taken 3
        -:  357:        {
        -:  358:            /* Clear interrupt flag */
       18:  359:            retVal = FlexCAN_ClearInterruptFlag(instance, IndexOfMb);
call    0 returned 18
        -:  360:            /* Check whether MB is active */
       18:  361:            if (((((sp_base->RAMn[IndexOfMb * WORD_LENGTH + OFFSET_START_OF_MB]) >> MB_CODE_SHIFT) & 0x0F) != CODE_INACTIVE_TX) &&
branch  0 taken 15 (fallthrough)
branch  1 taken 3
       15:  362:                ((((sp_base->RAMn[IndexOfMb * WORD_LENGTH + OFFSET_START_OF_MB]) >> MB_CODE_SHIFT) & 0x0F) != CODE_ABORT_TRANSMISSION) &&
branch  0 taken 12 (fallthrough)
branch  1 taken 3
       12:  363:                ((((sp_base->RAMn[IndexOfMb * WORD_LENGTH + OFFSET_START_OF_MB]) >> MB_CODE_SHIFT) & 0x0F) != CODE_INACTIVE_RX))
branch  0 taken 3 (fallthrough)
branch  1 taken 9
        -:  364:            {
        -:  365:                /* Write ABORT code to the CODE field */
        3:  366:                sp_base->RAMn[IndexOfMb * WORD_LENGTH + OFFSET_START_OF_MB] &= ~(MB_CODE_MASK);
        3:  367:                sp_base->RAMn[IndexOfMb * WORD_LENGTH + OFFSET_START_OF_MB] |= (CODE_ABORT_TRANSMISSION << MB_CODE_SHIFT);
        -:  368:                /* Clear the corresponding IFLAG */
        3:  369:                retVal = FlexCAN_ClearInterruptFlag(instance, IndexOfMb);
call    0 returned 3
        -:  370:            }
        -:  371:            /* Config TX message buffer to send */
       18:  372:            retVal = FlexCAN_Config_Tx_MessageBuffer(instance, IndexOfMb, mbData);
call    0 returned 18
       18:  373:            retVal = FLEXCAN_RETURN_CODE_SUCCESS;
        -:  374:        }
        -:  375:        else
        -:  376:        {
        3:  377:            retVal = FLEXCAN_RETURN_CODE_FAIL;
        -:  378:        }
        -:  379:    }
        -:  380:
       24:  381:    return retVal;
        -:  382:}
        -:  383:
function FlexCAN_Receive called 12 returned 100% blocks executed 100%
       12:  384:FlexCAN_ReturnCode_t FlexCAN_Receive(uint32_t instance, uint8_t IndexOfMb, FlexCAN_TX_MessageBuffer_t *mbData)
        -:  385:{
       12:  386:    uint8_t indexData = 0;
       12:  387:    FlexCAN_ReturnCode_t retVal = FLEXCAN_RETURN_CODE_FAIL;
        -:  388:    CAN_Type *sp_base;
        -:  389:
       12:  390:    retVal = FlexCAN_Get_Base_Address(instance, &sp_base);
call    0 returned 12
       12:  391:    if (retVal == FLEXCAN_RETURN_CODE_SUCCESS)
branch  0 taken 9 (fallthrough)
branch  1 taken 3
        -:  392:    {
        9:  393:        if (IndexOfMb <= RANGE_OF_MB)
branch  0 taken 6 (fallthrough)
branch  1 taken 3
        -:  394:        {
        -:  395:            /* Waiting CAN update mailbox data by move-in process, wait for busy bit be negated */
        6:  396:            while ((sp_base->RAMn[IndexOfMb * WORD_LENGTH] >> MB_CODE_SHIFT) & CODE_BUSY)
branch  0 taken 0
branch  1 taken 6 (fallthrough)
        -:  397:            {
        -:  398:                /* Do nothing */
        -:  399:            }
        -:  400:            /* Get data and configuration from MB */
        6:  401:            mbData->cfID.id = 0;
        6:  402:            mbData->cfID.id = (sp_base->RAMn[IndexOfMb * WORD_LENGTH + OFFSET_ID_OF_MB] & MB_ID_MASK) >> MB_ID_SHIFT;
        6:  403:            mbData->cfControl.dlc = (sp_base->RAMn[IndexOfMb * WORD_LENGTH + OFFSET_START_OF_MB] & MB_DLC_MASK) >> MB_DLC_SHIFT;
       54:  404:            for (indexData = 0U; indexData < (uint8_t)mbData->cfControl.dlc; indexData++)
branch  0 taken 48
branch  1 taken 6 (fallthrough)
        -:  405:            {
       48:  406:                mbData->dataByte[indexData] = (uint8_t)(sp_base->RAMn[IndexOfMb * WORD_LENGTH + OFFSET_DATA_START_OF_MB + (indexData / NUM_BYTES_EACH_WORD)] >> (THREE_BYTES - ONE_BYTE * (indexData % NUM_BYTES_EACH_WORD)));
        -:  407:            }
        6:  408:            mbData->cfID.prio = 0;
        -:  409:            /* Read free running timer to unlock mailbox */
        6:  410:            (void)sp_base->TIMER;
        6:  411:            retVal = FLEXCAN_RETURN_CODE_SUCCESS;
        -:  412:        }
        -:  413:        else
        -:  414:        {
        3:  415:            retVal = FLEXCAN_RETURN_CODE_FAIL;
        -:  416:        }
        -:  417:    }
        -:  418:
       12:  419:    return retVal;
        -:  420:}
        -:  421:
function FlexCAN_ConfigInterrupt called 9 returned 100% blocks executed 100%
        9:  422:FlexCAN_ReturnCode_t FlexCAN_ConfigInterrupt(uint32_t instance, uint8_t IndexOfMb)
        -:  423:{
        9:  424:    FlexCAN_ReturnCode_t retVal = FLEXCAN_RETURN_CODE_FAIL;
        -:  425:    CAN_Type *sp_base;
        -:  426:
        9:  427:    retVal = FlexCAN_Get_Base_Address(instance, &sp_base);
call    0 returned 9
        9:  428:    if (retVal == FLEXCAN_RETURN_CODE_SUCCESS)
branch  0 taken 6 (fallthrough)
branch  1 taken 3
        -:  429:    {
        6:  430:        FlexCAN_Enter_Freeze_Mode(instance);
call    0 returned 6
        -:  431:        /* Enable interrupt for both transmission and reception */
        6:  432:        sp_base->IMASK1 |= (1 << IndexOfMb);
        6:  433:        FlexCAN_Exit_Freeze_Mode(instance);
call    0 returned 6
        -:  434:    }
        -:  435:
        9:  436:    return retVal;
        -:  437:}
        -:  438:
function FlexCAN_InitIRQ called 30 returned 100% blocks executed 100%
       30:  439:FlexCAN_ReturnCode_t FlexCAN_InitIRQ(uint32_t instance, IRQn_Type irqIndex, FlexCAN_CallbackIRQ CAN_MiddlewareCallback)
        -:  440:{
       30:  441:    FlexCAN_ReturnCode_t retVal = FLEXCAN_RETURN_CODE_FAIL;
        -:  442:    CAN_Type *sp_base;
       30:  443:    if (NULL != CAN_MiddlewareCallback)
branch  0 taken 27 (fallthrough)
branch  1 taken 3
        -:  444:    {
       27:  445:        retVal = FlexCAN_Get_Base_Address(instance, &sp_base);
call    0 returned 27
        -:  446:    }
        -:  447:
       30:  448:    if (retVal == FLEXCAN_RETURN_CODE_SUCCESS)
branch  0 taken 24 (fallthrough)
branch  1 taken 6
        -:  449:    {
       24:  450:        if ((irqIndex >= CAN0_ORed_IRQn) && (irqIndex <= CAN2_ORed_0_15_MB_IRQn))
branch  0 taken 21 (fallthrough)
branch  1 taken 3
branch  2 taken 18 (fallthrough)
branch  3 taken 3
        -:  451:        {
       18:  452:            S32_NVIC->ISER[irqIndex / 32] |= (1 << (irqIndex % 32));
       18:  453:           switch (instance)
branch  0 taken 6
branch  1 taken 6
branch  2 taken 6
        -:  454:           {
        6:  455:            case FLEXCAN_INSTANCE_0:
        6:  456:                s_callbackIrq_0 = CAN_MiddlewareCallback;
        6:  457:                break;
        6:  458:            case FLEXCAN_INSTANCE_1:
        6:  459:                s_callbackIrq_1 = CAN_MiddlewareCallback;
        6:  460:                break;
        6:  461:            default: //FLEXCAN_INSTANCE_2
        6:  462:                s_callbackIrq_2 = CAN_MiddlewareCallback;
        6:  463:                break;
        -:  464:           }
       18:  465:            retVal = FLEXCAN_RETURN_CODE_SUCCESS;
        -:  466:        }
        -:  467:        else
        -:  468:        {
        6:  469:            retVal = FLEXCAN_RETURN_CODE_FAIL;
        -:  470:        }
        -:  471:    }
        -:  472:
       30:  473:    return retVal;
        -:  474:}
        -:  475:
function CAN0_ORed_0_15_MB_IRQHandler called 6 returned 100% blocks executed 100%
        6:  476:void CAN0_ORed_0_15_MB_IRQHandler()
        -:  477:{
        6:  478:    uint8_t flagIndex = 0;
        -:  479:    CAN_Type *sp_base;
        6:  480:    uint8_t g_flagInterruptMB = 0;
        -:  481:
        6:  482:    sp_base = CAN0;
      111:  483:    for (flagIndex = 0; flagIndex < RANGE_OF_MB; flagIndex++)
branch  0 taken 108
branch  1 taken 3 (fallthrough)
        -:  484:    {
      108:  485:        if (((sp_base->IFLAG1) >> flagIndex) & 1U)
branch  0 taken 3 (fallthrough)
branch  1 taken 105
        -:  486:        {
        3:  487:            g_flagInterruptMB = flagIndex;
        3:  488:            break;
        -:  489:        }
        -:  490:    }
        6:  491:    s_callbackIrq_0(g_flagInterruptMB);
call    0 returned 6
        6:  492:}
        -:  493:
function CAN1_ORed_0_15_MB_IRQHandler called 6 returned 100% blocks executed 100%
        6:  494:void CAN1_ORed_0_15_MB_IRQHandler()
        -:  495:{
        6:  496:    uint8_t flagIndex = 0;
        -:  497:    CAN_Type *sp_base;
        6:  498:    uint8_t g_flagInterruptMB = 0;
        -:  499:
        6:  500:    sp_base = CAN1;
      111:  501:    for (flagIndex = 0; flagIndex < RANGE_OF_MB; flagIndex++)
branch  0 taken 108
branch  1 taken 3 (fallthrough)
        -:  502:    {
      108:  503:        if (((sp_base->IFLAG1) >> flagIndex) & 1U)
branch  0 taken 3 (fallthrough)
branch  1 taken 105
        -:  504:        {
        3:  505:            g_flagInterruptMB = flagIndex;
        3:  506:            break;
        -:  507:        }
        -:  508:    }
        6:  509:    s_callbackIrq_1(g_flagInterruptMB);
call    0 returned 6
        6:  510:}
        -:  511:
function CAN2_ORed_0_15_MB_IRQHandler called 6 returned 100% blocks executed 100%
        6:  512:void CAN2_ORed_0_15_MB_IRQHandler()
        -:  513:{
        6:  514:    uint8_t flagIndex = 0;
        -:  515:    CAN_Type *sp_base;
        6:  516:    uint8_t g_flagInterruptMB = 0;
        -:  517:
        6:  518:    sp_base = CAN2;
      111:  519:    for (flagIndex = 0; flagIndex < RANGE_OF_MB; flagIndex++)
branch  0 taken 108
branch  1 taken 3 (fallthrough)
        -:  520:    {
      108:  521:        if (((sp_base->IFLAG1) >> flagIndex) & 1U)
branch  0 taken 3 (fallthrough)
branch  1 taken 105
        -:  522:        {
        3:  523:            g_flagInterruptMB = flagIndex;
        3:  524:            break;
        -:  525:        }
        -:  526:    }
        6:  527:    s_callbackIrq_2(g_flagInterruptMB);
call    0 returned 6
        6:  528:}
        -:  529:
        -:  530:#ifdef __cplusplus
        -:  531:}
        -:  532:#endif
        -:  533:/*******************************************************************************
        -:  534: * End of file
        -:  535: ******************************************************************************/
